(def rapply (x y) (apply y x))
(def call (x y) (apply x (list y)))
(def rcall (x y) (apply y (list x)))
(def strict-apply (func argl)
     (if (= (len (head func)) (len argl))
         (apply func argl)
         (err "Argument count does not match the operand count")))
(def strict-rapply (argl func) (strict-apply func argl))
(def rest () (&process-next (apply &rest &args)))
(def neck (thing) (head (rest thing)))
(def &next-thing-is-gen (next-thing)
     (apply (head next-thing)
            (&rest next-thing)))
(def &process-next (next-thing)
     (if (gen? (head next-thing))
         (&next-thing-is-gen (head next-thing))
         next-thing))
(def seq (starting finishing) 
     (if (< starting finishing)
         (list starting (gen seq (+ 1 starting) finishing))
         (list finishing)))
(def eager-map (stencil lst)
     (if (> (len lst) 1)
         (cons (stencil (head lst)) (map stencil (rest lst)))
         (list (stencil (head lst)))))
(def map (stencil lst)
     (if (> (len lst) 1)
         (list (stencil (head lst)) (gen mappy stencil (rest lst)))
         (list (stencil (head lst)))))
(def nth (num lst)
     (if (> num 0)
         (nth (- num 1) (rest lst))
         (head lst)))
(def take (num lst)
     (if (> num 0)
         (cons (head lst) (take (- num 1) (rest lst)))
         nil))
(def repeat (expr)
     (list expr
           (gen repeat expr)))
(def &enumerate (amountKnown remaining)
     (if (true? remaining)
         (&enumerate (+ 1 amountKnown) (rest remaining))
         amountKnown))
(def enumerate (things)
     (&enumerate 0 things))
(def resolve (things)
     (take (enumerate things) things))
(def print ()
     (apply &print (resolve &args)))
(def filt (predicate sequence) 
     (if (> (len sequence) 0)
         (if (predicate (head sequence))
             (cons (head sequence) (filt predicate (rest sequence)))
             (filt predicate (rest sequence))  )) )
(def fold-left (stencil initial sequence)
     (if (> (len sequence) 1)
         (fold-left stencil (stencil initial (head sequence)) (rest sequence))
         (stencil initial (head sequence))))
(def fold-right (stencil initial sequence)
     (if (> (len sequence) 1)
         (fold-left stencil (stencil (head sequence) initial) (rest sequence))
         (stencil initial (head sequence))))
(def fold (stencil sequence) (fold-left stencil (head sequence) (rest sequence)))
(def foldr (stencil sequence) (fold-right stencil (head sequence) (rest sequence)))
(def &mult (x y) (apply + (take y (repeat x))))
(def multiply (x) (fold-left &mult x &args))
(def * () (apply multiply &args))
(def &expt (x y)
     (apply multiply (take y (repeat x))))
(def exponent (x)
     (fold-left &expt x &args))
(def ^ () (apply exponent &args))
