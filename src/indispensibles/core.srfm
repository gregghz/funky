(def not_ (x) (if (true? x) nil true))
(def pedantry_ (orig errz)
     (if errz (head errz) orig))
(def pedantry (subj)
     (if (grid? subj)
         subj
         (pedantry_ subj (filt error? subj))))
(def safely-apply_ (proc argl) (if (error? argl) argl (apply proc argl)))
(def safely-apply (proc argl) (safely-apply_ proc (pedantry argl)))
(def rapply (argl proc) (safely-apply proc argl))
(def call (proc arggy) (safely-apply proc (list arggy)))
(def rcall (arggy proc) (call proc arggy))
(def strict-apply (proc argl)
     (if (= (len (head proc)) (len argl))
         (safely-apply proc argl)
         (err "Argument count does not match the operand count")))
(def strict-rapply (argl func) (strict-apply func argl))
(def rest () (proc-next_ (apply rest_ &args)))
(def neck (thing) (head (rest thing)))
(def resolve-gen_ (next-thing)
     (apply (head next-thing)
            (rest_ next-thing)))
(def proc-next_ (next-thing)
     (if (gen? (head next-thing))
         (resolve-gen_ (head next-thing))
         next-thing))
(def seq (starting finishing) 
     (if (< starting finishing)
         (list starting (gen seq (+ 1 starting) finishing))
         (list finishing)))
(def eager-map (stencil lst)
     (if (> (len lst) 1)
         (cons (stencil (head lst)) (map stencil (rest lst)))
         (list (stencil (head lst)))))
(def map (stencil lst)
     (if (> (len lst) 1)
         (list (stencil (head lst)) (gen mappy stencil (rest lst)))
         (list (stencil (head lst)))))
(def nth (num lst)
     (if (> num 0)
         (nth (- num 1) (rest lst))
         (head lst)))
(def take (num lst)
     (if (> num 0)
         (cons (head lst) (take (- num 1) (rest lst)))
         nil))
(def repeat (expr)
     (list expr
           (gen repeat expr)))
(def enumerate_ (amountKnown remaining)
     (if (true? remaining)
         (enumerate_ (+ 1 amountKnown) (rest remaining))
         amountKnown))
(def enumerate (things)
     (enumerate_ 0 things))
(def resolve (things)
     (take (enumerate things) things))
(def print ()
     (apply print_ (resolve &args)))
(def filt (predicate sequence) 
     (if (> (len sequence) 0)
         (if (predicate (head sequence))
             (cons (head sequence) (filt predicate (rest sequence)))
             (filt predicate (rest sequence))  )) )
(def fold-left (stencil initial sequence)
     (if (> (len sequence) 1)
         (fold-left stencil (stencil initial (head sequence)) (rest sequence))
         (stencil initial (head sequence))))
(def fold-right (stencil initial sequence)
     (if (> (len sequence) 1)
         (fold-left stencil (stencil (head sequence) initial) (rest sequence))
         (stencil initial (head sequence))))
(def fold (stencil sequence) (fold-left stencil (head sequence) (rest sequence)))
(def foldr (stencil sequence) (fold-right stencil (head sequence) (rest sequence)))
(def &mult (x y) (apply + (take y (repeat x))))
(def multiply (x) (fold-left &mult x &args))
(def * () (apply multiply &args))
(def &expt (x y)
     (apply multiply (take y (repeat x))))
(def exponent (x)
     (fold-left &expt x &args))
(def ^ () (apply exponent &args))
